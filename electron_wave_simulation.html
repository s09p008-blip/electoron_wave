<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ÈõªÂ≠ê„ÅÆ‰∫åÈáçÊÄß„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥ - ILD</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { 
      font-family: Arial, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      min-height: 100vh;
      color: white;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback } = React;

    // Constants
    const SLIT_Y1 = 150;
    const SLIT_Y2 = 200;
    const SLIT_WIDTH = 10;
    const SLIT_X = 180;
    const SCREEN_X = 340;
    const CENTER_Y = 175;
    
    // Cover area (for hiding the slit region when not observing)
    const COVER_X1 = 100;
    const COVER_X2 = 280;
    const COVER_Y1 = 60;
    const COVER_Y2 = 290;

    // Wave interference calculation
    const calculateInterference = (y) => {
      const d = SLIT_Y2 - SLIT_Y1;
      const L = SCREEN_X - SLIT_X;
      const wavelength = 22;
      const deltaY = y - CENTER_Y;
      const pathDiff = (d * deltaY) / L;
      const phase = (2 * Math.PI * pathDiff) / wavelength;
      const envelope = Math.pow(Math.sin(deltaY / 40 + 0.001) / (deltaY / 40 + 0.001), 2) || 1;
      const interference = Math.pow(Math.cos(phase / 2), 2);
      return Math.max(0, interference * Math.min(envelope * 1.5, 1));
    };

    // Classical two-peak distribution
    const calculateClassical = (y) => {
      const sigma = 18;
      const peak1 = Math.exp(-Math.pow(y - SLIT_Y1, 2) / (2 * sigma * sigma));
      const peak2 = Math.exp(-Math.pow(y - SLIT_Y2, 2) / (2 * sigma * sigma));
      return (peak1 + peak2) * 0.9;
    };

    function ElectronWaveSimulation() {
      const [mode, setMode] = useState('light');
      const [isRunning, setIsRunning] = useState(false);
      const [particles, setParticles] = useState([]);
      const [screenHits, setScreenHits] = useState([]);
      const [particleCount, setParticleCount] = useState(0);
      const [speed, setSpeed] = useState(1.5);
      const [observerOn, setObserverOn] = useState(false);
      const [waveTime, setWaveTime] = useState(0);
      const [showDistribution, setShowDistribution] = useState(false);
      const animationRef = useRef(null);
      const lastTimeRef = useRef(0);

      // Should we show the cover? Only for electron/single modes when observer is OFF
      const showCover = (mode === 'electron' || mode === 'single') && !observerOn;

      const reset = useCallback(() => {
        setIsRunning(false);
        setParticles([]);
        setScreenHits([]);
        setParticleCount(0);
        setWaveTime(0);
        if (animationRef.current) cancelAnimationFrame(animationRef.current);
      }, []);

      const getTargetY = useCallback((isObserved) => {
        const calcFunc = isObserved ? calculateClassical : calculateInterference;
        let attempts = 0;
        while (attempts < 150) {
          const y = CENTER_Y + (Math.random() - 0.5) * 200;
          if (y < 60 || y > 290) continue;
          const probability = calcFunc(y);
          if (Math.random() < probability) return y;
          attempts++;
        }
        return isObserved ? (Math.random() > 0.5 ? SLIT_Y1 : SLIT_Y2) : CENTER_Y;
      }, []);

      const spawnParticle = useCallback(() => {
        const isObserved = mode === 'particle' || observerOn;
        return {
          id: Date.now() + Math.random(),
          x: 25,
          y: CENTER_Y + (Math.random() - 0.5) * 30,
          targetY: getTargetY(isObserved),
          throughSlit: Math.random() > 0.5 ? 1 : 2,
          phase: Math.random() * Math.PI * 2,
          observed: isObserved,
        };
      }, [mode, observerOn, getTargetY]);

      useEffect(() => {
        if (!isRunning) return;
        const animate = (timestamp) => {
          const deltaTime = timestamp - lastTimeRef.current;
          if (deltaTime > 16) {
            lastTimeRef.current = timestamp;
            
            const lightSpeedFactor = 0.4;
            const waveSpeedMultiplier = mode === 'light' ? lightSpeedFactor : 1;
            setWaveTime(t => t + 0.12 * speed * waveSpeedMultiplier);

            if (mode !== 'light') {
              setParticles(prev => {
                const updated = prev.map(p => {
                  const newX = p.x + 3 * speed;
                  let newY = p.y;
                  if (newX > SLIT_X - 25 && newX < SLIT_X + 25) {
                    const targetSlitY = p.throughSlit === 1 ? SLIT_Y1 : SLIT_Y2;
                    newY = p.y + (targetSlitY - p.y) * 0.1;
                  } else if (newX >= SLIT_X + 25) {
                    newY = p.y + (p.targetY - p.y) * 0.05;
                  }
                  return { ...p, x: newX, y: newY, phase: p.phase + 0.25 * speed };
                });

                const stillActive = [];
                updated.forEach(p => {
                  if (p.x >= SCREEN_X) {
                    setScreenHits(prev => [...prev, { y: p.targetY }]);
                    setParticleCount(c => c + 1);
                  } else {
                    stillActive.push(p);
                  }
                });
                return stillActive;
              });

              const spawnRate = mode === 'single' ? 0.025 : 0.15;
              const maxParticles = mode === 'single' ? 1 : 12;
              setParticles(prev => {
                if (prev.length < maxParticles && Math.random() < spawnRate * speed) {
                  return [...prev, spawnParticle()];
                }
                return prev;
              });
            }
          }
          animationRef.current = requestAnimationFrame(animate);
        };
        animationRef.current = requestAnimationFrame(animate);
        return () => { if (animationRef.current) cancelAnimationFrame(animationRef.current); };
      }, [isRunning, mode, speed, spawnParticle]);

      const modeInfo = {
        light: { title: '„Éá„É¢1: ÂÖâÔºàÊ≥¢Ôºâ', color: '#ff4444', showObserver: false },
        particle: { title: '„Éá„É¢2: „Éú„Éº„É´ÔºàÁ≤íÂ≠êÔºâ', color: '#ffaa00', showObserver: false },
        electron: { title: '„Éá„É¢3: ÈõªÂ≠ê„Éì„Éº„É†', color: '#00aaff', showObserver: true },
        single: { title: '„Éá„É¢4: Âçò‰∏ÄÈõªÂ≠ê', color: '#00ff88', showObserver: true },
      };

      const buildHistogram = () => {
        const bins = {};
        const binSize = 4;
        screenHits.forEach(hit => {
          const bin = Math.floor(hit.y / binSize) * binSize;
          bins[bin] = (bins[bin] || 0) + 1;
        });
        const maxCount = Math.max(...Object.values(bins), 1);
        return { bins, maxCount };
      };

      const { bins, maxCount } = buildHistogram();

      const generatePattern = (calcFunc, yMin = 60, yMax = 290, step = 3) => {
        const pattern = [];
        for (let y = yMin; y <= yMax; y += step) {
          pattern.push({ y, intensity: calcFunc(y) });
        }
        return pattern;
      };

      const interferencePattern = generatePattern(calculateInterference);
      const classicalPattern = generatePattern(calculateClassical);
      const isInterference = mode === 'light' || ((mode === 'electron' || mode === 'single') && !observerOn);
      const currentTheoryPattern = (mode === 'particle' || observerOn) ? classicalPattern : interferencePattern;

      const renderWaves = () => {
        const waves = [];
        for (let i = 0; i < 10; i++) {
          const radius = ((waveTime * 35 + i * 28) % 250);
          if (radius > 8) {
            [SLIT_Y1, SLIT_Y2].forEach((slitY, idx) => {
              waves.push(
                <circle
                  key={`wave-${idx}-${i}`}
                  cx={SLIT_X + 5}
                  cy={slitY}
                  r={radius}
                  fill="none"
                  stroke={modeInfo[mode].color}
                  strokeWidth="2.5"
                  opacity={Math.max(0, 0.7 - radius / 300)}
                  clipPath="url(#rightClip)"
                />
              );
            });
          }
        }
        return waves;
      };

      // Check if particle is inside the cover area
      const isInsideCover = (x) => {
        return x > COVER_X1 && x < COVER_X2;
      };

      return (
        <div style={{ maxWidth: 750, margin: '0 auto', padding: 12 }}>
          <h1 style={{ textAlign: 'center', marginBottom: 4, fontSize: 20 }}>
            ÈõªÂ≠ê„ÅÆ‰∫åÈáçÊÄß„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥
          </h1>
          <p style={{ textAlign: 'center', color: '#666', marginBottom: 10, fontSize: 11 }}>
            Interactive Lecture Demonstration
          </p>

          {/* Mode buttons */}
          <div style={{ display: 'flex', gap: 6, justifyContent: 'center', marginBottom: 8, flexWrap: 'wrap' }}>
            {Object.entries(modeInfo).map(([key, info]) => (
              <button
                key={key}
                onClick={() => { reset(); setMode(key); setObserverOn(false); setShowDistribution(false); }}
                style={{
                  padding: '5px 10px',
                  border: mode === key ? `2px solid ${info.color}` : '2px solid #444',
                  borderRadius: 5,
                  background: mode === key ? `${info.color}22` : '#2a2a4a',
                  color: mode === key ? info.color : '#777',
                  cursor: 'pointer',
                  fontSize: 11,
                  fontWeight: mode === key ? 'bold' : 'normal',
                }}
              >
                {info.title}
              </button>
            ))}
          </div>

          {/* Observer toggle */}
          {modeInfo[mode].showObserver && (
            <div style={{
              display: 'flex',
              justifyContent: 'center',
              alignItems: 'center',
              gap: 12,
              marginBottom: 8,
              padding: 6,
              background: observerOn ? '#ff444420' : '#33333340',
              borderRadius: 6,
              border: observerOn ? '2px solid #ff6666' : '2px solid #555'
            }}>
              <span style={{ fontSize: 14 }}>üî¨</span>
              <span style={{ color: '#ddd', fontWeight: 'bold', fontSize: 11 }}>
                Ë¶≥Ê∏¨Ë£ÖÁΩÆÔºà„Å©„Å°„Çâ„ÅÆ„Çπ„É™„ÉÉ„Éà„ÇíÈÄö„Å£„Åü„ÅãÊ§úÂá∫Ôºâ
              </span>
              <button
                onClick={() => { reset(); setObserverOn(!observerOn); }}
                style={{
                  padding: '4px 14px',
                  border: 'none',
                  borderRadius: 4,
                  background: observerOn ? '#ff5555' : '#666',
                  color: '#fff',
                  cursor: 'pointer',
                  fontWeight: 'bold',
                  fontSize: 11
                }}
              >
                {observerOn ? 'ON' : 'OFF'}
              </button>
            </div>
          )}

          {/* Main area */}
          <div style={{ display: 'flex', gap: 8, marginBottom: 8 }}>
            
            {/* Left: Experiment visualization */}
            <div style={{ 
              flex: showDistribution ? '1 1 58%' : '1 1 100%',
              background: '#080815',
              borderRadius: 8,
              border: '1px solid #333',
              overflow: 'hidden',
              transition: 'flex 0.3s'
            }}>
              <svg width="100%" viewBox="0 0 380 320" style={{ display: 'block' }}>
                <defs>
                  <clipPath id="rightClip">
                    <rect x={SLIT_X + 5} y="0" width="400" height="400" />
                  </clipPath>
                  <filter id="glow">
                    <feGaussianBlur stdDeviation="2.5" result="coloredBlur"/>
                    <feMerge><feMergeNode in="coloredBlur"/><feMergeNode in="SourceGraphic"/></feMerge>
                  </filter>
                  {/* Pattern for cover */}
                  <pattern id="coverPattern" patternUnits="userSpaceOnUse" width="8" height="8">
                    <rect width="8" height="8" fill="#1a1a2a"/>
                    <path d="M0 0L8 8M8 0L0 8" stroke="#252538" strokeWidth="1"/>
                  </pattern>
                </defs>

                <rect width="380" height="320" fill="#080815"/>

                {/* Labels */}
                <text x="40" y="20" fill="#555" fontSize="9">Áô∫Â∞ÑÊ∫ê</text>
                {!showCover && <text x={SLIT_X - 5} y="20" fill="#555" fontSize="9">‰∫åÈáç„Çπ„É™„ÉÉ„Éà</text>}
                <text x={SCREEN_X + 5} y="20" fill="#555" fontSize="9">„Çπ„ÇØ„É™„Éº„É≥</text>

                {/* Source */}
                <rect x="15" y={CENTER_Y - 25} width="40" height="50" fill="#1a1a2a" rx="4" stroke="#333"/>
                <circle cx="35" cy={CENTER_Y} r="10" fill={modeInfo[mode].color} filter="url(#glow)" opacity="0.7"/>
                <circle cx="35" cy={CENTER_Y} r="4" fill="#fff"/>

                {/* Incident waves for light */}
                {mode === 'light' && isRunning && Array.from({ length: 6 }, (_, i) => {
                  const x = 55 + ((waveTime * 35 + i * 22) % 120);
                  return <line key={`inc-${i}`} x1={x} y1={CENTER_Y - 50} x2={x} y2={CENTER_Y + 50} stroke={modeInfo[mode].color} strokeWidth="2" opacity="0.35"/>;
                })}

                {/* Slit barrier - only show if not covered */}
                {!showCover && (
                  <>
                    <rect x={SLIT_X} y="35" width={SLIT_WIDTH} height={SLIT_Y1 - 35 - SLIT_WIDTH/2} fill="#3a4055" stroke="#4a5065"/>
                    <rect x={SLIT_X} y={SLIT_Y1 + SLIT_WIDTH/2} width={SLIT_WIDTH} height={SLIT_Y2 - SLIT_Y1 - SLIT_WIDTH} fill="#3a4055" stroke="#4a5065"/>
                    <rect x={SLIT_X} y={SLIT_Y2 + SLIT_WIDTH/2} width={SLIT_WIDTH} height={285 - SLIT_Y2 - SLIT_WIDTH/2} fill="#3a4055" stroke="#4a5065"/>
                    <rect x={SLIT_X} y={SLIT_Y1 - SLIT_WIDTH/2} width={SLIT_WIDTH} height={SLIT_WIDTH} fill="#0a0a15"/>
                    <rect x={SLIT_X} y={SLIT_Y2 - SLIT_WIDTH/2} width={SLIT_WIDTH} height={SLIT_WIDTH} fill="#0a0a15"/>
                  </>
                )}

                {/* Observer indicators */}
                {modeInfo[mode].showObserver && observerOn && (
                  <g>
                    <circle cx={SLIT_X - 8} cy={SLIT_Y1} r="8" fill="#ff4444" opacity="0.4"/>
                    <circle cx={SLIT_X - 8} cy={SLIT_Y2} r="8" fill="#ff4444" opacity="0.4"/>
                    <text x={SLIT_X - 8} y={SLIT_Y1 + 4} fill="#ff4444" fontSize="10" textAnchor="middle">üëÅ</text>
                    <text x={SLIT_X - 8} y={SLIT_Y2 + 4} fill="#ff4444" fontSize="10" textAnchor="middle">üëÅ</text>
                  </g>
                )}

                {/* Concentric waves for light mode */}
                {mode === 'light' && isRunning && renderWaves()}

                {/* Screen */}
                <rect x={SCREEN_X} y="35" width="10" height="250" fill="#1a1a2a" stroke="#333"/>

                {/* Light interference on screen */}
                {mode === 'light' && isRunning && interferencePattern.map((p, i) => (
                  <rect key={i} x={SCREEN_X} y={p.y - 1.5} width="10" height="3" fill={modeInfo[mode].color} opacity={p.intensity * 0.95}/>
                ))}

                {/* Particles - only show if outside cover area OR if observer is on */}
                {mode !== 'light' && particles.map(p => {
                  const hidden = showCover && isInsideCover(p.x);
                  if (hidden) return null;
                  
                  return (
                    <g key={p.id}>
                      <ellipse cx={p.x - 8} cy={p.y} rx="12" ry="3" fill={modeInfo[mode].color} opacity="0.15"/>
                      <circle cx={p.x} cy={p.y} r={mode === 'particle' ? 7 : 4} fill={modeInfo[mode].color} filter="url(#glow)"/>
                      {!p.observed && (mode === 'electron' || mode === 'single') && !showCover && (
                        <circle cx={p.x} cy={p.y} r={8 + Math.sin(p.phase) * 4} fill="none" stroke={modeInfo[mode].color} strokeWidth="1.5" opacity="0.35"/>
                      )}
                    </g>
                  );
                })}

                {/* Screen hits */}
                {mode !== 'light' && screenHits.slice(-200).map((hit, i) => (
                  <circle key={i} cx={SCREEN_X + 5} cy={hit.y} r="2" fill={modeInfo[mode].color} opacity="0.7"/>
                ))}

                {/* Cover box - rendered on top when observer is OFF */}
                {showCover && (
                  <g>
                    {/* Main cover body */}
                    <rect 
                      x={COVER_X1} 
                      y={COVER_Y1} 
                      width={COVER_X2 - COVER_X1} 
                      height={COVER_Y2 - COVER_Y1} 
                      fill="url(#coverPattern)"
                      stroke="#444"
                      strokeWidth="2"
                      rx="4"
                    />
                    {/* Cover label */}
                    <text 
                      x={(COVER_X1 + COVER_X2) / 2} 
                      y={(COVER_Y1 + COVER_Y2) / 2 - 10} 
                      fill="#666" 
                      fontSize="12" 
                      textAnchor="middle"
                      fontWeight="bold"
                    >
                      üö´ Ë¶≥Ê∏¨„Åó„Å¶„ÅÑ„Å™„ÅÑ
                    </text>
                    <text 
                      x={(COVER_X1 + COVER_X2) / 2} 
                      y={(COVER_Y1 + COVER_Y2) / 2 + 8} 
                      fill="#555" 
                      fontSize="9" 
                      textAnchor="middle"
                    >
                      „Å©„Å°„Çâ„ÅÆ„Çπ„É™„ÉÉ„Éà„ÇíÈÄö„Å£„Åü„Åã
                    </text>
                    <text 
                      x={(COVER_X1 + COVER_X2) / 2} 
                      y={(COVER_Y1 + COVER_Y2) / 2 + 20} 
                      fill="#555" 
                      fontSize="9" 
                      textAnchor="middle"
                    >
                      „Çè„Åã„Çâ„Å™„ÅÑ
                    </text>
                    {/* Entry/exit holes visual */}
                    <rect x={COVER_X1 - 2} y={CENTER_Y - 15} width="6" height="30" fill="#080815" stroke="#444" rx="2"/>
                    <rect x={COVER_X2 - 4} y={COVER_Y1 + 20} width="6" height={COVER_Y2 - COVER_Y1 - 40} fill="#080815" stroke="#444" rx="2"/>
                  </g>
                )}

                {/* Counter */}
                <text x="365" y="310" fill="#555" fontSize="10" textAnchor="end">
                  {mode === 'particle' ? '„Éú„Éº„É´' : mode === 'light' ? '' : 'ÈõªÂ≠ê'}{mode !== 'light' ? `: ${particleCount}` : ''}
                </text>
              </svg>
            </div>

            {/* Right: Distribution panel */}
            {showDistribution && (
              <div style={{ 
                flex: '1 1 42%',
                background: '#0a0a18',
                borderRadius: 8,
                border: '1px solid #333',
                padding: 8
              }}>
                <h3 style={{ margin: '0 0 6px 0', fontSize: 11, color: '#aaa', textAlign: 'center' }}>
                  „Çπ„ÇØ„É™„Éº„É≥‰∏ä„ÅÆÂàÜÂ∏É
                </h3>

                <svg width="100%" viewBox="0 0 240 250" style={{ display: 'block' }}>
                  <text x="6" y="18" fill="#444" fontSize="8">‰∏ä</text>
                  <text x="6" y="240" fill="#444" fontSize="8">‰∏ã</text>

                  {[0, 1, 2, 3, 4].map(i => (
                    <line key={i} x1="22" y1={45 + i * 45} x2="235" y2={45 + i * 45} stroke="#222" strokeWidth="1"/>
                  ))}

                  <g>
                    <text x="170" y="32" fill="#555" fontSize="8">ÁêÜË´ñ‰∫àÊ∏¨</text>
                    {currentTheoryPattern.map((p, i) => {
                      const barY = ((p.y - 60) / 230) * 200 + 40;
                      return (
                        <rect
                          key={i}
                          x="22"
                          y={barY - 1.5}
                          width={p.intensity * 85}
                          height="3"
                          fill={isInterference ? '#00aaff' : '#ffaa00'}
                          opacity="0.25"
                        />
                      );
                    })}
                  </g>

                  {mode !== 'light' && (
                    <g>
                      <text x="26" y="32" fill="#888" fontSize="8">ÂÆüÈ®ìÁµêÊûú</text>
                      {Object.entries(bins).map(([y, count]) => {
                        const barY = ((parseFloat(y) - 60) / 230) * 200 + 40;
                        const barWidth = (count / maxCount) * 100;
                        return (
                          <rect
                            key={y}
                            x="22"
                            y={barY - 2}
                            width={barWidth}
                            height="4"
                            fill={modeInfo[mode].color}
                            opacity="0.9"
                            rx="1"
                          />
                        );
                      })}
                    </g>
                  )}

                  {mode === 'light' && isRunning && interferencePattern.map((p, i) => {
                    const barY = ((p.y - 60) / 230) * 200 + 40;
                    return (
                      <rect
                        key={i}
                        x="22"
                        y={barY - 1.5}
                        width={p.intensity * 100}
                        height="3"
                        fill={modeInfo[mode].color}
                        opacity="0.9"
                      />
                    );
                  })}

                  <line x1="17" y1={((SLIT_Y1 - 60) / 230) * 200 + 40} x2="22" y2={((SLIT_Y1 - 60) / 230) * 200 + 40} stroke="#666" strokeWidth="2"/>
                  <line x1="17" y1={((SLIT_Y2 - 60) / 230) * 200 + 40} x2="22" y2={((SLIT_Y2 - 60) / 230) * 200 + 40} stroke="#666" strokeWidth="2"/>
                  <text x="10" y={((SLIT_Y1 - 60) / 230) * 200 + 43} fill="#666" fontSize="7">S1</text>
                  <text x="10" y={((SLIT_Y2 - 60) / 230) * 200 + 43} fill="#666" fontSize="7">S2</text>
                </svg>

                <div style={{ 
                  display: 'flex', 
                  justifyContent: 'center', 
                  gap: 14, 
                  marginTop: 4,
                  padding: '5px 0',
                  borderTop: '1px solid #222'
                }}>
                  <div style={{ display: 'flex', alignItems: 'center', gap: 4 }}>
                    <div style={{ width: 18, height: 3, background: modeInfo[mode].color, borderRadius: 1 }}/>
                    <span style={{ color: '#888', fontSize: 9 }}>ÂÆüÈ®ì</span>
                  </div>
                  <div style={{ display: 'flex', alignItems: 'center', gap: 4 }}>
                    <div style={{ width: 18, height: 3, background: isInterference ? '#00aaff44' : '#ffaa0044', borderRadius: 1 }}/>
                    <span style={{ color: '#666', fontSize: 9 }}>ÁêÜË´ñ</span>
                  </div>
                </div>
              </div>
            )}
          </div>

          {/* Controls */}
          <div style={{ display: 'flex', gap: 8, justifyContent: 'center', alignItems: 'center', flexWrap: 'wrap' }}>
            <button
              onClick={() => setIsRunning(!isRunning)}
              style={{
                padding: '7px 20px',
                fontSize: 12,
                border: 'none',
                borderRadius: 5,
                background: isRunning ? '#ee4444' : '#44aa44',
                color: 'white',
                cursor: 'pointer',
                fontWeight: 'bold'
              }}
            >
              {isRunning ? '‚è∏ ÂÅúÊ≠¢' : '‚ñ∂ ÈñãÂßã'}
            </button>
            <button
              onClick={reset}
              style={{
                padding: '7px 14px',
                fontSize: 12,
                border: '2px solid #444',
                borderRadius: 5,
                background: 'transparent',
                color: '#999',
                cursor: 'pointer'
              }}
            >
              üîÑ „É™„Çª„ÉÉ„Éà
            </button>
            <div style={{ display: 'flex', alignItems: 'center', gap: 4 }}>
              <span style={{ color: '#666', fontSize: 10 }}>ÈÄüÂ∫¶:</span>
              <input 
                type="range" 
                min="0.5" 
                max="3" 
                step="0.5" 
                value={speed} 
                onChange={(e) => setSpeed(parseFloat(e.target.value))} 
                style={{ width: 60 }}
              />
              <span style={{ color: '#999', fontSize: 10, width: 24 }}>{speed}x</span>
            </div>
            
            <label style={{ 
              display: 'flex', 
              alignItems: 'center', 
              gap: 4, 
              cursor: 'pointer',
              padding: '4px 8px',
              background: showDistribution ? '#ffffff15' : 'transparent',
              borderRadius: 4,
              border: '1px solid #444'
            }}>
              <input 
                type="checkbox" 
                checked={showDistribution} 
                onChange={(e) => setShowDistribution(e.target.checked)}
                style={{ cursor: 'pointer', width: 12, height: 12 }}
              />
              <span style={{ color: '#aaa', fontSize: 10 }}>ÂàÜÂ∏É„Ç∞„É©„Éï„ÇíË°®Á§∫</span>
            </label>
          </div>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<ElectronWaveSimulation />);
  </script>
</body>
</html>
